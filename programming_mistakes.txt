stupid mistakes:
- not size(), not sizeof(), not len(), but length()
- not append(List, A, New) but append(List, [A], New)
- if complex, use helper predicates to break problem down
  sounds obvious, but all your practice has been on predicates
  which don't require helper ones, so you're not used to it!


key predicates:
- sort(A, SortedA)
- reverse(A, reversedA)
- append(L1, L2, L1andL2)
- member(X, L)
- length(L, X)
- findall(X, G, L)
- setof(X, G, L) orders AND removes duplicates


emacs trick:
C-<number> <character>
types <character> <number> times


singleton variables:
- to state facts about fixed variables, don't use variable notation,
use inverted commas. eg 
andgate('And'). rather than andgate(And).


recursion:
- treat the head, recursively call the tail, append the two
- always make recursive call asap


mysort():
- you can write your own in 1 predicate using setof()


setof(X, G, L):
- setof additionally orders the list in ascending order and
  removes duplicates
- to make setof accumulate into 1 list like findall, use ^
- CRUCIAL stuff to remember about ^
  see ListsSetofEx/parents.pl


findall(X, G, L) vs setof:
- findall takes all bindings, for all unbound variables in G, for all
solutions to G	
- setof takes all bindings, for unbound variables in G AND NOT IN X,
for all solutions to G
- use maximum ^ to get setof to accumulate like findall
- see ListsSetofEx/parents.pl


failures:
- flatten a nested list structure
- 
